---
title: Attributes
description: Rock language overview attributes
---

Attributes are additional metadata that can be applied to various language constructs.  
They can have parameters with optional associated string value.

Attributes can be applied to:
- Items
- Statements
- Struct fields
- Enum variants

### Procedure attributes

#### `test`
Include the procedure in the test suite.  
Test procedures cannot have any input parameters.

```rs
#[test]
proc test_lexer() {
    let input = "let x = 10;";
    mut lexer = lexer_init();
    let success = lexer_lex(&mut lexer, input);
    assert(success);
}
```

:::caution
Testing and results are work in progress.
:::

#### `inline`
Suggests that the procedure should be inlined when called.  
This is recommended to be used on small procedures.

```rs
#[inline]
proc timer_tick(self: &mut Timer) {
    self.counter += 1;
}
```

#### `builtin`
Built-in procedures are used in the core library.
This attribute signifies that the procedure body should be empty,
and the implementation will be generated by the compiler.

:::caution
No examples available.
:::

### Enum attributes

#### `repr(C)`
Match `C` enum layout, required for ffi.

```rs
#[repr(C)]
enum VkPolygonMode {
    Fill,
    Line,
    Point,
}
```

#### `repr(int_type)`
Specifies which integer type to use for the enum tag.  
Required when any of the enum variants has an explicit value.

```rs
#[repr(u8)]
enum Building {
    House = 2,
    Castle,
    Stable,
}
```

### Struct attributes

#### `repr(C)`
Match `C` struct layout, required for ffi.

```rs
#[repr(C)]
struct VkExtent2D {
    width: u32,
    height: u32,
}
```

### Global attributes

#### `thread_local`
Indicates that global variable is thread-local,
meaning that each thread in a program will have its own separate instance of the variable.  
This is useful when you want each thread to maintain its own independent state for that variable, preventing data races and ensuring that the variable's state is not shared across threads.

```rs
#[thread_local]
global COUNTER: u32 = 0;
```

### Config attributes
Config attributes are used for conditional compilation, and can be applied to any valid target.
Multiple config attributes can be applied to the same target, working as a logical `&&` operation.

#### `cfg`
True, when all parameters are true.

```rs
#[cfg(target_os = "windows")]
proc platform_init() {
    // windows specific logic
}

#[cfg(target_os = "linux")]
proc platform_init() {
    // linux specific logic
}
```

#### `cfg_not`
True, when none of the parameters are true.

```rs
import core:libc.{ printf }

proc greet() {
    #[cfg(target_os = "windows")]
    printf("Hi, from windows!");

    #[cfg_not(target_os = "windows")]
    printf("Hi, from unix!");
}
```

#### `cfg_any`
True, when any of the parameters are true.

```rs
proc setup_arch() {
    #[cfg_any(build_kind = "debug", target_arch = "x86_64")]
    setup_arch_x86_64();
    #[cfg_any(build_kind = "debug", target_arch = "aarch64")]
    setup_arch_aarch64();
}
```

### Config parameters
Each config attribute can have multiple key-value parameters.  
Full list of key-value pairs is provided below:

#### `target`
- `"x86_64-pc-windows-msvc"`
- `"x86_64-unknown-linux-gnu"`
- `"x86_64-apple-darwin"`
- `"aarch64-pc-windows-msvc"`
- `"aarch64-unknown-linux-gnu"`
- `"aarch64-apple-darwin"`

#### `target_arch`
- `"x86_64"`
- `"aarch64"`

#### `target_os`
- `"windows"`
- `"linux"`
- `"macos"`

#### `target_ptr_width`
- `"32"`
- `"64"`

#### `build_kind`
- `"debug"`
- `"release"`
